<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Runner War 3D</title>
  <style>
    html, body { width:100%; height:100%; margin:0; overflow:hidden; background:#000; }
    #renderCanvas { width:100%; height:100%; display:block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 20px;
      z-index: 10;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="hud">Score: <span id="score">0</span> | Coins: <span id="coins">0</span></div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    let scene, player, lane = 0, score = 0, coins = 0, speed = 0.3;
    const lanes = [-2, 0, 2];
    let roadSegments = [];

    const createScene = () => {
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.2);

      const camera = new BABYLON.FollowCamera("camera", new BABYLON.Vector3(0, 5, -10), scene);
      camera.radius = 10;
      camera.heightOffset = 5;
      camera.rotationOffset = 180;
      camera.lockedTarget = new BABYLON.Vector3(0, 1, 5);

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 0.9;

      // Player placeholder (capsule)
      player = BABYLON.MeshBuilder.CreateCapsule("player", { height: 2, radius: 0.5 }, scene);
      player.position.y = 1;
      player.position.z = 0;

      // Ground segments
      for (let i = 0; i < 5; i++) {
        createRoadSegment(i * 20);
      }

      return scene;
    };

    function createRoadSegment(zPos) {
      const ground = BABYLON.MeshBuilder.CreateGround("ground" + zPos, { width: 8, height: 20 }, scene);
      ground.position.z = zPos;
      ground.material = new BABYLON.StandardMaterial("mat", scene);
      ground.material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
      roadSegments.push(ground);

      // Add some random coins & obstacles
      for (let i = 0; i < 3; i++) {
        if (Math.random() < 0.5) {
          let coin = BABYLON.MeshBuilder.CreateSphere("coin", { diameter: 0.5 }, scene);
          coin.position.set(lanes[i], 1, zPos + Math.random() * 18 - 9);
          coin.material = new BABYLON.StandardMaterial("cMat", scene);
          coin.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
        }
        if (Math.random() < 0.3) {
          let obstacle = BABYLON.MeshBuilder.CreateBox("obs", { size: 1 }, scene);
          obstacle.position.set(lanes[i], 0.5, zPos + Math.random() * 18 - 9);
          obstacle.material = new BABYLON.StandardMaterial("oMat", scene);
          obstacle.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
        }
      }
    }

    // Input controls
    window.addEventListener("keydown", (ev) => {
      if (ev.key === "ArrowLeft" && lane > -1) lane--;
      if (ev.key === "ArrowRight" && lane < 1) lane++;
      if (ev.key === "ArrowUp") playerJump();
      if (ev.key === "ArrowDown") playerSlide();
    });

    function playerJump() {
      if (!player.isJumping) {
        player.isJumping = true;
        let anim = new BABYLON.Animation("jump", "position.y", 60,
          BABYLON.Animation.ANIMATIONTYPE_FLOAT,
          BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

        let keys = [
          { frame: 0, value: player.position.y },
          { frame: 15, value: 3 },
          { frame: 30, value: 1 }
        ];
        anim.setKeys(keys);
        player.animations = [];
        player.animations.push(anim);
        scene.beginAnimation(player, 0, 30, false, 1, () => { player.isJumping = false; });
      }
    }

    function playerSlide() {
      if (!player.isSliding) {
        player.isSliding = true;
        let oldScale = player.scaling.y;
        player.scaling.y = 0.5;
        setTimeout(() => {
          player.scaling.y = oldScale;
          player.isSliding = false;
        }, 800);
      }
    }

    engine.runRenderLoop(() => {
      if (scene) {
        // Move forward
        player.position.z += speed;
        scene.activeCamera.lockedTarget = player.position;

        // Smooth lane movement
        player.position.x += (lanes[lane + 1] - player.position.x) * 0.2;

        // Recycle road
        roadSegments.forEach((seg) => {
          if (player.position.z - seg.position.z > 30) {
            seg.position.z += 100;
            createRoadSegment(seg.position.z);
          }
        });

        // Score
        score += 1;
        document.getElementById("score").innerText = score;

        // Coin collection
        scene.meshes.forEach((m) => {
          if (m.name === "coin" && m.isVisible) {
            if (player.intersectsMesh(m, false)) {
              coins++;
              m.dispose();
              document.getElementById("coins").innerText = coins;
            }
          }
          if (m.name === "obs" && player.intersectsMesh(m, false)) {
            alert("Game Over! Final Score: " + score + " | Coins: " + coins);
            engine.stopRenderLoop();
          }
        });

        scene.render();
      }
    });

    createScene();
  </script>
</body>
</html>
