<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple Shooting Game ‚Äî Enhanced</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a35;
      --text: #e6ecff;
      --accent: #7cc4ff;
      --danger: #ff6b6b;
      --ok: #6bff95;
      --muted: #98a2b3;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 70% -10%, #1a254d 0%, var(--bg) 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .wrap {
      width: min(96vw, 900px);
      aspect-ratio: 16/9;
      background: linear-gradient(180deg, #0c1329 0%, #0a0f21 100%);
      border: 2px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      position: relative;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 0 80px rgba(124,196,255,0.05);
      overflow: hidden;
    }
    header.ui {
      position: absolute; inset: 0 0 auto 0; height: 56px; display: flex; align-items: center; gap: 16px; padding: 10px 14px;
      background: linear-gradient(180deg, rgba(18,26,53,0.7) 0%, rgba(18,26,53,0.2) 100%);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      z-index: 3;
    }
    .badge { font-weight: 700; letter-spacing: .5px; padding: 6px 10px; border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; background: rgba(124,196,255,0.1); }
    .spacer { flex: 1; }
    .btn {
      appearance: none; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06);
      color: var(--text); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-weight: 700; letter-spacing: .4px;
      transition: transform .08s ease, background .2s ease, box-shadow .2s ease;
    }
    .btn:hover { background: rgba(255,255,255,0.12); box-shadow: 0 0 0 4px rgba(124,196,255,0.15) inset; }
    .btn:active { transform: translateY(1px) scale(0.98); }

    canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }

    .screen { position: absolute; inset: 0; display: grid; place-items: center; background: radial-gradient(1000px 600px at 50% -10%, rgba(124,196,255,0.06), transparent 60%); z-index: 2; }
    .card {
      width: min(88%, 560px);
      background: rgba(10,15,33,0.8);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 22px 22px 18px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.6), inset 0 0 80px rgba(124,196,255,0.06);
      backdrop-filter: blur(8px);
      text-align: center;
    }
    h1 { margin: 0 0 8px; font-size: clamp(22px, 3.5vw, 34px); letter-spacing: .6px; }
    p { margin: 4px 0; color: var(--muted); }
    kbd { background: #0e1736; border: 1px solid rgba(255,255,255,0.15); border-bottom-color: rgba(255,255,255,0.25); border-radius: 6px; padding: 2px 6px; font-weight: 700; color: var(--text); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .hud { position: absolute; inset: 56px 0 0 0; padding: 8px 12px; display: flex; justify-content: space-between; color: var(--text); font-weight: 800; letter-spacing: .5px; z-index: 2; text-shadow: 0 2px 4px rgba(0,0,0,0.7); }
    .hud .stat { background: rgba(0,0,0,0.25); padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); }

    /* Mobile controls */
    .touch {
      position: absolute; inset: auto 0 10px 0; display: none; gap: 10px; justify-content: center; z-index: 3; padding: 0 10px;
    }
    .pad { width: 64px; height: 64px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); display: grid; place-items: center; font-weight: 900; }
    .pad:active { transform: translateY(1px) scale(.98); }

    @media (pointer: coarse) {
      .touch { display: flex; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="ui">
      <span class="badge">SIMPLE SHOOTER</span>
      <div class="spacer"></div>
      <button id="btnSfx" class="btn" title="Toggle Sound (M)">üîä On</button>
      <button id="btnPause" class="btn" title="P">Pause</button>
      <button id="btnRestart" class="btn">Restart</button>
    </header>

    <div class="hud">
      <div class="stat">Score: <span id="score">0</span></div>
      <div class="stat">Lives: <span id="lives">3</span></div>
      <div class="stat">Best: <span id="best">0</span></div>
      <div class="stat">Wave: <span id="wave">1</span></div>
    </div>

    <canvas id="game" width="1280" height="720" aria-label="Game Canvas"></canvas>

    <div id="startScreen" class="screen">
      <div class="card">
        <h1>Simple Shooting Game</h1>
        <p>Move with <kbd>‚Üê</kbd>/<kbd>‚Üí</kbd> or <kbd>A</kbd>/<kbd>D</kbd>. Shoot with <kbd>Space</kbd>. Pause with <kbd>P</kbd>. Toggle sound with <kbd>M</kbd>.</p>
        <p class="mono">Destroy waves, grab <span style="color:var(--ok);font-weight:700;">health pickups</span>, and watch out for tougher enemies and bosses!</p>
        <p style="margin-top:12px;">
          <button id="btnPlay" class="btn" style="font-size:16px; padding:10px 16px;">Play</button>
        </p>
      </div>
    </div>

    <div id="gameOver" class="screen" style="display:none;">
      <div class="card">
        <h1>Game Over</h1>
        <p>Your Score: <span id="finalScore">0</span></p>
        <p>Best: <span id="finalBest">0</span></p>
        <p style="margin-top:12px; display:flex; gap:10px; justify-content:center;">
          <button id="btnReplay" class="btn">Replay</button>
          <button id="btnHome" class="btn">Home</button>
        </p>
      </div>
    </div>

    <div class="touch">
      <button class="pad" id="left">‚óÄ</button>
      <button class="pad" id="fire">‚óè</button>
      <button class="pad" id="right">‚ñ∂</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // Resize canvas for crisp rendering
    function fitCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * DPR);
      canvas.height = Math.floor(rect.height * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // draw using CSS pixels
    }
    new ResizeObserver(fitCanvas).observe(canvas);
    fitCanvas();

    // ===== Simple Synth SFX (no external files) =====
    const SFX = (() => {
      let enabled = true;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const actx = AudioCtx ? new AudioCtx() : null;
      function env(node, t, attack=0.01, decay=0.08, sustain=0.0001) {
        if (!node || !actx) return;
        const now = actx.currentTime;
        node.gain.cancelScheduledValues(now);
        node.gain.setValueAtTime(0.0001, now);
        node.gain.exponentialRampToValueAtTime(1, now + attack);
        node.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
      }
      function tone(freq=440, dur=0.1, type='square', detune=0) {
        if (!enabled || !actx) return;
        const o = actx.createOscillator();
        const g = actx.createGain();
        o.type = type; o.frequency.value = freq; o.detune.value = detune;
        o.connect(g); g.connect(actx.destination);
        const now = actx.currentTime;
        env(g, now, Math.min(0.02, dur*0.3), Math.max(0.05, dur*0.7));
        o.start(now);
        o.stop(now + dur);
      }
      function noise(dur=0.2) {
        if (!enabled || !actx) return;
        const buffer = actx.createBuffer(1, actx.sampleRate * dur, actx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
        const src = actx.createBufferSource(); src.buffer = buffer;
        const g = actx.createGain();
        src.connect(g); g.connect(actx.destination);
        env(g, actx.currentTime, 0.005, dur-0.005);
        src.start();
      }
      return {
        set enabled(v){ enabled = !!v; },
        get enabled(){ return enabled; },
        shoot(){ tone(720, 0.08, 'square'); },
        explode(){ noise(0.25); tone(90, 0.18, 'sawtooth'); },
        hit(){ tone(220, 0.12, 'triangle'); },
        pickup(){ tone(660, 0.08, 'sine'); tone(990, 0.1, 'sine', 3); },
        gameover(){ tone(300, 0.25, 'triangle'); tone(180, 0.4, 'sine', -5); }
      };
    })();

    // UI elements
    const ui = {
      score: document.getElementById('score'),
      lives: document.getElementById('lives'),
      best: document.getElementById('best'),
      wave: document.getElementById('wave'),
      start: document.getElementById('startScreen'),
      over: document.getElementById('gameOver'),
      finalScore: document.getElementById('finalScore'),
      finalBest: document.getElementById('finalBest'),
      btnPlay: document.getElementById('btnPlay'),
      btnReplay: document.getElementById('btnReplay'),
      btnHome: document.getElementById('btnHome'),
      btnPause: document.getElementById('btnPause'),
      btnRestart: document.getElementById('btnRestart'),
      btnSfx: document.getElementById('btnSfx'),
      left: document.getElementById('left'),
      right: document.getElementById('right'),
      fire: document.getElementById('fire'),
    };

    // Game state
    const state = {
      running: false,
      paused: false,
      wave: 1,
      score: 0,
      lives: 3,
      best: Number(localStorage.getItem('simpleShooterBest') || 0),
      keys: new Set(),
      t: 0,
      enemies: [],
      bullets: [],
      eBullets: [],
      particles: [],
      pickups: [],
      maxLives: 5,
    };

    ui.best.textContent = state.best;

    // Entities
    const player = {
      x: 100, y: 0, w: 42, h: 18, speed: 5, cooldown: 0,
      color: '#7cc4ff',
      reset() { this.x = canvas.width / DPR / 2 - this.w / 2; this.y = canvas.height / DPR - 80; this.cooldown = 0; }
    };
    player.reset();

    // Enemy type templates
    const EnemyTypes = {
      grunt:   { hp: 1, vx: 1.2, vy: 0.3, color: '#ff8b8b', score: 12, fire: 0.002 },
      fast:    { hp: 1, vx: 2.0, vy: 0.45, color: '#a0ffb1', score: 16, fire: 0.002 },
      tank:    { hp: 3, vx: 0.8, vy: 0.25, color: '#ffcf70', score: 28, fire: 0.0025 },
      sniper:  { hp: 2, vx: 1.0, vy: 0.3, color: '#bba0ff', score: 24, fire: 0.0045 },
      boss:    { hp: 18, vx: 1.2, vy: 0.2, color: '#ffd166', score: 200, fire: 0.006 }
    };

    function spawnWave() {
      const w = canvas.width / DPR;
      const bossWave = (state.wave % 5 === 0);
      state.enemies.length = 0;

      if (bossWave) {
        // Mini-boss centered
        const bw = 120, bh = 60;
        state.enemies.push({ x: w/2 - bw/2, y: 80, w: bw, h: bh, type: 'boss', ...EnemyTypes.boss, t: Math.random()*100 });
        return;
      }

      const cols = Math.min(10, 5 + Math.floor(state.wave * 0.6));
      const rows = Math.max(1, Math.min(5, 2 + Math.floor(state.wave * 0.3)));
      const gapX = 18, gapY = 20;
      const startX = 40, startY = 70;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const ex = startX + c * (34 + gapX);
          const ey = startY + r * (26 + gapY);
          const roll = Math.random();
          let type = 'grunt';
          if (roll > 0.85) type = 'tank';
          else if (roll > 0.6) type = 'fast';
          else if (roll > 0.4) type = 'sniper';
          const base = EnemyTypes[type];
          const hpScale = 1 + Math.floor(state.wave/6);
          state.enemies.push({ x: ex, y: ey, w: 30, h: 20, type, hp: base.hp*hpScale, vx: base.vx + state.wave*0.03, vy: base.vy + state.wave*0.01, color: base.color, scoreVal: base.score + state.wave, fire: base.fire + state.wave*0.0003, t: Math.random()*100 });
        }
      }
    }

    function shoot(x, y) {
      state.bullets.push({ x, y, w: 4, h: 10, vy: -9 });
      SFX.shoot();
    }
    function enemyShoot(x, y) {
      state.eBullets.push({ x, y, w: 4, h: 10, vy: 5 + Math.random()*2 });
    }

    function aabb(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.h + a.y > b.y; }

    function explode(x, y, color = '#fff') {
      for (let i = 0; i < 16; i++) {
        state.particles.push({ x, y, vx: (Math.random()*2-1)*3, vy: (Math.random()*2-1)*3, life: 30 + Math.random()*20, color });
      }
      SFX.explode();
    }

    function update() {
      if (!state.running || state.paused) return;
      state.t++;

      // Player input
      const speed = player.speed;
      if (state.keys.has('ArrowLeft') || state.keys.has('a')) player.x -= speed;
      if (state.keys.has('ArrowRight') || state.keys.has('d')) player.x += speed;
      player.x = Math.max(10, Math.min(canvas.width / DPR - player.w - 10, player.x));

      // Player shooting
      player.cooldown = Math.max(0, player.cooldown - 1);
      if ((state.keys.has(' ') || state.keys.has('Space')) && player.cooldown === 0) {
        shoot(player.x + player.w/2 - 2, player.y - 6);
        player.cooldown = 12;
      }

      // Bullets
      for (let b of state.bullets) b.y += b.vy;
      state.bullets = state.bullets.filter(b => b.y + b.h > 0);

      for (let b of state.eBullets) b.y += b.vy;
      state.eBullets = state.eBullets.filter(b => b.y < canvas.height / DPR + 40);

      // Enemies movement and shooting
      for (let e of state.enemies) {
        const sway = e.type === 'fast' ? 0.06 : (e.type === 'boss' ? 0.02 : 0.03);
        e.x += Math.sin((state.t + e.t) * sway) * e.vx;
        e.y += e.vy * 0.3;
        if (Math.random() < (e.fire || 0.002)) enemyShoot(e.x + e.w/2 - 2, e.y + e.h);
      }

      // Collisions: player bullets vs enemies
      for (let b of state.bullets) {
        for (let e of state.enemies) {
          if (aabb(b, e)) {
            e.hp -= 1; b.y = -9999; // remove bullet
            if (e.hp <= 0) {
              explode(e.x + e.w/2, e.y + e.h/2, '#ffdd7c');
              state.score += e.scoreVal || (10 + Math.floor(state.wave * 1.2));
              // 15% chance to drop a health pickup (less during boss to avoid trivializing)
              const dropRate = (e.type === 'boss') ? 0.08 : 0.15;
              if (Math.random() < dropRate) {
                state.pickups.push({ x: e.x + e.w/2 - 8, y: e.y + e.h/2, w: 16, h: 16, vy: 2.4, type: 'health' });
              }
              e.dead = true;
            } else {
              SFX.hit();
            }
          }
        }
      }
      state.enemies = state.enemies.filter(e => !e.dead && e.y < canvas.height / DPR - 120);

      // Collisions: enemy bullets vs player
      for (let eb of state.eBullets) {
        if (aabb(eb, player)) {
          eb.y = canvas.height / DPR + 999;
          explode(player.x + player.w/2, player.y, '#ff6b6b');
          state.lives -= 1; ui.lives.textContent = state.lives;
          if (state.lives <= 0) {
            endGame();
            return;
          }
        }
      }

      // Pickups
      for (let p of state.pickups) p.y += p.vy;
      // collect or drop off-screen
      state.pickups = state.pickups.filter(p => {
        if (p.y > canvas.height / DPR + 20) return false;
        if (aabb(p, player)) {
          if (p.type === 'health' && state.lives < state.maxLives) {
            state.lives = Math.min(state.maxLives, state.lives + 1);
            ui.lives.textContent = state.lives;
            state.score += 5;
            SFX.pickup();
          }
          return false;
        }
        return true;
      });

      // Next wave
      if (state.enemies.length === 0) {
        state.wave += 1; ui.wave.textContent = state.wave;
        spawnWave();
        // small heal every 3 waves
        if (state.wave % 3 === 0) { state.lives = Math.min(state.maxLives, state.lives + 1); ui.lives.textContent = state.lives; }
      }

      // Particles
      for (let p of state.particles) { p.x += p.vx; p.y += p.vy; p.life -= 1; }
      state.particles = state.particles.filter(p => p.life > 0);

      ui.score.textContent = state.score;

      draw();
      requestAnimationFrame(update);
    }

    function draw() {
      const w = canvas.width / DPR, h = canvas.height / DPR;
      // background
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, '#0b1229');
      g.addColorStop(1, '#090e1f');
      ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);

      // starfield
      ctx.globalAlpha = 0.6;
      for (let i = 0; i < 60; i++) {
        const x = (i * 53 + (state.t * 0.3 + i * 7) % w) % w;
        const y = (i * 97 + (state.t * 0.2 + i * 13) % h) % h;
        ctx.fillStyle = i % 7 === 0 ? '#7cc4ff' : '#ffffff';
        ctx.fillRect((x|0), (y|0), 2, 2);
      }
      ctx.globalAlpha = 1;

      // player
      ctx.save();
      ctx.translate(player.x, player.y);
      ship(ctx, player.w, player.h, player.color);
      ctx.restore();

      // bullets
      ctx.fillStyle = '#a2d6ff';
      for (let b of state.bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

      // enemy bullets
      ctx.fillStyle = '#ff9aa5';
      for (let b of state.eBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

      // enemies
      for (let e of state.enemies) {
        ctx.save(); ctx.translate(e.x, e.y);
        alien(ctx, e.w, e.h, e.color);
        ctx.restore();
      }

      // pickups
      for (let p of state.pickups) {
        drawPickup(ctx, p);
      }

      // particles
      for (let p of state.particles) { ctx.globalAlpha = Math.max(0, Math.min(1, p.life/40)); ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3); }
      ctx.globalAlpha = 1;
    }

    function ship(ctx, w, h, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, h); ctx.lineTo(w*0.2, h*0.6); ctx.lineTo(w*0.5, 0); ctx.lineTo(w*0.8, h*0.6); ctx.lineTo(w, h); ctx.closePath();
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fillRect(w*0.42, h*0.18, w*0.16, h*0.26); // canopy
    }

    function alien(ctx, w, h, color) {
      ctx.fillStyle = color;
      const r = 6;
      roundRect(ctx, 0, 0, w, h, r); ctx.fill();
      ctx.fillStyle = '#1a0f24';
      ctx.fillRect(w*0.18, h*0.35, w*0.24, h*0.18);
      ctx.fillRect(w*0.58, h*0.35, w*0.24, h*0.18);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(0, h*0.75, w, h*0.25);
    }

    function drawPickup(ctx, p) {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.fillStyle = '#3cff94';
      ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0c142e';
      ctx.fillRect(7, 4, 2, 8); // plus vertical
      ctx.fillRect(4, 7, 8, 2); // plus horizontal
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function startGame() {
      state.running = true; state.paused = false; state.wave = 1; state.score = 0; state.lives = 3; ui.wave.textContent = 1; ui.lives.textContent = 3; ui.score.textContent = 0;
      state.enemies.length = 0; state.bullets.length = 0; state.eBullets.length = 0; state.particles.length = 0; state.pickups.length = 0;
      player.reset();
      spawnWave();
      ui.start.style.display = 'none';
      ui.over.style.display = 'none';
      requestAnimationFrame(update);
    }

    function endGame() {
      state.running = false;
      state.best = Math.max(state.best, state.score);
      localStorage.setItem('simpleShooterBest', String(state.best));
      ui.finalScore.textContent = state.score;
      ui.finalBest.textContent = state.best;
      ui.best.textContent = state.best;
      ui.over.style.display = '';
      SFX.gameover();
    }

    function togglePause(force) {
      const p = force !== undefined ? !!force : !state.paused;
      state.paused = p;
    }

    // Controls
    window.addEventListener('keydown', (e) => {
      const k = e.key;
      if (["ArrowLeft","ArrowRight"," ","Space","a","d"].includes(k)) e.preventDefault();
      if (k === 'p' || k === 'P') togglePause();
      if (k === 'm' || k === 'M') toggleSfx();
      state.keys.add(k);
      if ((k === ' ' || k === 'Space') && state.running && !state.paused) {
        // quick tap shoot (immediate)
        if (player.cooldown === 0) {
          shoot(player.x + player.w/2 - 2, player.y - 6);
          player.cooldown = 12;
        }
      }
    });
    window.addEventListener('keyup', (e) => { state.keys.delete(e.key); });

    // Buttons
    ui.btnPlay?.addEventListener('click', startGame);
    ui.btnReplay?.addEventListener('click', startGame);
    ui.btnHome?.addEventListener('click', () => { ui.over.style.display = 'none'; ui.start.style.display = ''; });
    ui.btnPause?.addEventListener('click', () => togglePause());
    ui.btnRestart?.addEventListener('click', startGame);
    ui.btnSfx?.addEventListener('click', toggleSfx);

    function toggleSfx(){
      SFX.enabled = !SFX.enabled;
      ui.btnSfx.textContent = SFX.enabled ? 'üîä On' : 'üîá Off';
    }

    // Touch controls
    let touchDir = 0, touchFire = false;
    function touchLoop() {
      if (touchDir < 0) state.keys.add('ArrowLeft'); else state.keys.delete('ArrowLeft');
      if (touchDir > 0) state.keys.add('ArrowRight'); else state.keys.delete('ArrowRight');
      if (touchFire) state.keys.add(' '); else state.keys.delete(' ');
      requestAnimationFrame(touchLoop);
    }
    touchLoop();
    ui.left.addEventListener('pointerdown', () => touchDir = -1);
    ui.left.addEventListener('pointerup', () => touchDir = 0);
    ui.right.addEventListener('pointerdown', () => touchDir = 1);
    ui.right.addEventListener('pointerup', () => touchDir = 0);
    ui.fire.addEventListener('pointerdown', () => touchFire = true);
    ui.fire.addEventListener('pointerup', () => touchFire = false);

    // Start screen visible on load
  </script>
</body>
</html>
